head	1.8;
access;
symbols;
locks;
comment	@# @;


1.8
date	2021.01.08.02.09.08;	author -;	state -;
branches;
next	1.7;

1.7
date	2020.01.23.22.08.22;	author -;	state -;
branches;
next	1.6;

1.6
date	2020.01.23.22.06.47;	author -;	state -;
branches;
next	1.5;

1.5
date	2020.01.15.23.47.11;	author -;	state -;
branches;
next	1.4;

1.4
date	2020.01.14.00.51.50;	author -;	state -;
branches;
next	1.3;

1.3
date	2020.01.03.20.10.53;	author -;	state -;
branches;
next	1.2;

1.2
date	2019.12.13.02.34.03;	author -;	state -;
branches;
next	1.1;

1.1
date	2019.12.13.02.32.01;	author -;	state -;
branches;
next	;


desc
@@


1.8
log
@-
@
text
@$Id: SCORE,v 1.7 2020-01-23 14:08:22-08 - - $

Copy all of the files in this directory into the student's
directory.  For each point deduction, give a reason.  Numbers in
parens are the max points for each check.

*****************************************************************

SOURCE CODE.

     Run mk.build

     (3) Checksource was silent, did not complain.  No extra
	 files were submitted, except as per asgt spec.
         Header files are all *.h and implementation files
         are consistently *.cpp.

     (3) Used good consistent indentation.  Did not use any
	 one-letter idents, used only meaningful idents.
	 Did not leave any commented-out code interspersed
	 with running code.

     Most of the work was in bigint.cpp

     (3) Has the constructor code been replaced properly?
         bigint::bigint ()
         bigint::bigint (int that) // or long as arg, OK too
         bigint::bigint (const string &that)

     (3) Ignore this point.  No points deduction for this.

     (3) Do op+ and op- just check for signs and then call
         ubigint operators to do the work?
         bigint bigint::operator+
         bigint bigint::operator-

     (3) operator* implemented using a loop within a loop
         as per the symbolic code in spec.

     (3) operator/ and operator% call udivide, which uses the
         iteration method described as "Egyptian".  Alternately,
         uses the algorithm outlined by Per Brinch Hansen's
         paper "Tour of the Minefield".

     (3) Is compare properly implemented?  It should first check
         signs, then only magnitudes when necessary.
         int bigint::compare (const bigint &that)

     (3) Do ubigint + and - properly link down the vector to
         make a new vector?  The signatures will vary from one
         solution to another, since they were not present in
         the original.
         ubigint::operator+
         ubigint::operator-

     (3) Operator<< properly split up output lines as for dc?
         ostream &operator<< (ostream &out, const bigint &that)

source points: /30
min 1, max 30

*****************************************************************

PROGRAM TESTING:

     If mk.build failed to create an executable binary,
     check to see if it is because of missing files the
     student did not submit.  If that is the case, copy
     those files from the original code directory and
     try again.  If that enabled ccompilation, deduct
(10) ten points for not submitting all files.

     If that did not fix thing, stop here.  Do not deduct
     the 10 points if compilation still fails.

     Run mk.tests
     For each of the tests verify that the $test.out.diffs
     are empty.  Stdout should be exactly the same as for dc.

     (3) test0-stk.in

     (3) test1-stk.in

     (3) test2-add.in

     (3) test3-sub.in

     (3) test4-mul.in

     (3) test5-div.in

     (3) test6-exp.in

     (9) Segmentation fault and leak check.
         Multiply by 2 the number of the above tests that resulted
         in a segmentation fault or other abort = (a)
         Assign (b) = 4 points if the valgrind indicated leaks
         or other memory errors.
         Set (c) = (a) + (b)
         Deduct (c) points or 9 points, whichever is smaller.

testing points: /30
min 0, max 30.

*****************************************************************

SUBTOTAL=
min 1, max 60

If pair programming, TOTALSCORE = SUBTOTAL - TOTAL1.
If not, TOTALSCORE = SUBTOTAL.

TOTALSCORE=
min 1, max 60

@


1.7
log
@-
@
text
@d1 1
a1 1
$Id: SCORE,v 1.6 2020-01-23 14:06:47-08 - - $
d16 1
a16 1
         are consistently *.cc or *.cpp.
d23 1
a23 1
     Most of the work was in bigint.cc
@


1.6
log
@-
@
text
@d1 1
a1 1
$Id: SCORE,v 1.2 2019-12-12 18:34:03-08 - - $
d40 1
a40 1
     (3) operator/ and operator% call div_rem, which uses the
d43 1
a43 1
         paper
@


1.5
log
@-
@
text
@d1 1
a1 1
$Id: SCORE,v 1.4 2020-01-13 16:51:50-08 - - $
d34 2
a35 2
         bigint bigint::operator=
         bigint bigint::operator=
d37 1
a37 1
     (3) operator= implemented using a loop within a loop
d40 1
a40 1
     (3) operator= and operator= call udivide, which uses the
d53 2
a54 2
         ubigint::operator=
         ubigint::operator=
@


1.4
log
@-
@
text
@d1 1
a1 1
$Id: SCORE,v 1.3 2020-01-03 12:10:53-08 - - $
d34 2
a35 2
         bigint bigint::operator+=
         bigint bigint::operator-=
d37 1
a37 1
     (3) operator*= implemented using a loop within a loop
d40 1
a40 1
     (3) operator/= and operator%= call udivide, which uses the
d53 2
a54 2
         ubigint::operator+=
         ubigint::operator-=
@


1.3
log
@-
@
text
@d1 1
a1 1
$Id: SCORE,v 1.2 2019-12-12 18:34:03-08 - - $
d40 1
a40 1
     (3) operator/= and operator%= call div_rem, which uses the
@


1.2
log
@-
@
text
@d1 1
a1 1
$Id: SCORE,v 1.1 2019-12-12 18:32:01-08 - - $
d34 2
a35 2
         bigint bigint::operator+
         bigint bigint::operator-
d37 1
a37 1
     (3) operator* implemented using a loop within a loop
d40 1
a40 1
     (3) operator/ and operator% call div_rem, which uses the
d53 2
a54 2
         ubigint::operator+
         ubigint::operator-
@


1.1
log
@-
@
text
@d1 1
a1 1
$Id: SCORE,v 1.5 2019-01-24 12:57:24-08 - - $
d67 8
a74 1
     stop here.  No output points if it does not build.
@
